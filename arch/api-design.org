
** API Design
So far everything we've talked about are definitely more "guidelines" than
"rules". They are meant to help guide our code into a state that is clean and
maintainable. Missing one or two guidelines shouldn't cause a code review to
fail -- while at the same time, it shouldn't be that hard to implement the
guideline anyways.

Pretty much everything above are things that can be changed without breaking
backwards compatibility. Changes like renaming variables, renaming packages, etc
-- there are refactoring tools which make these changes easy and simple to implement.

However, when it comes to API design we need to be less forgiving.

When it comes to the public API of a package, it pays to put considerable
thought into the initial design, because changing that design later is going to
be disruptive for people who are already using your API. Changing your public
API forces the existing user base to have to dedicate engineering resources to
upgrading across your API break. The larger the break, the more likely this task
will be considered low impact, but high risk, and likely to be pushed off in
light of other business priorities.

This is the same whether you're changing function names and arguments in your
code, or changing the routes your services provide.

So let's talk about Go code APIs, and some guidelines on how we can write good
APIs.

*** High Level
**** Design APIs That Are Hard To Misuse
#+BEGIN_QUOTE
APIs should be easy to use and hard to misuse. 

â€” [[https://www.infoq.com/articles/API-Design-Joshua-Bloch/][Josh Bloch]]
#+END_QUOTE

If you take anything away from this section, it should be this advice from Josh
Bloch. If an API is hard to use for simple things, then every invocation will
look complicated. When the actual invocation of the API is complicated it will
be less obvious and more likely to be overlooked.
***** Be wary of functions with several parameters of the same type
A good example of a simple looking, but hard to use correctly, API is one which
takes two or more parameters of the same type. Letâ€™s compare two function
signatures:

#+BEGIN_SRC go
func Max(a, b int) int
func CopyFile(to, from string) error
#+END_SRC

Whatâ€™s the difference between these two functions? Obviously one returns the
maximum of two numbers, the other copies a file, but thatâ€™s not the important
thing.

#+BEGIN_SRC go
Max(8, 10) // 10
Max(10, 8) // 10
#+END_SRC

Max is commutative; the order of its parameters does not matter. The maximum of
eight and ten is ten regardless of if I compare eight and ten or ten and eight.

However, this property does not hold true for =CopyFile=.

#+BEGIN_SRC go
CopyFile("/tmp/backup", "presentation.md")
CopyFile("presentation.md", "/tmp/backup")
#+END_SRC

Which one of these statements made a backup of your presentation and which one
overwrite your presentation with last weekâ€™s version? You canâ€™t tell without
consulting the documentation. A code reviewer cannot know if youâ€™ve got the
order correct without consulting the documentation.

The general advice is to try to avoid this situation. Just like long parameter
lists, indistinct parameter lists are a design smell.

However, a possible solution to this class of problem is to introduce a helper
type which will be responsible for calling =CopyFile= correctly.

#+BEGIN_SRC go
type Source string

func (src Source) CopyTo(dest string) error {
	return CopyFile(dest, string(src))
}

func main() {
	var from Source = "presentation.md"
	from.CopyTo("/tmp/backup")
}
#+END_SRC

In this way =CopyFile= is always called correctly and, given its poor API can
possibly be made private, further reducing the likelihood of misuse.
**** Design APIs For Their Default Use Case
Quite a few years ago now, [[https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis][Dave Cheney gave a talk on using functional options]]
to make APIs easier to use for their default case.

The gist of this talk was you should design your APIs for the common, or
default, use case. Said another way, your API should not require the caller to
provide parameters which they donâ€™t care about. More than being hard to use, you
place the user in the position of guessing reasonable values. If they are lucky,
the values they YOLOâ€™d have no impact. Thatâ€™s if they are lucky.

However! This isn't to say that every function should be designed this
way. Rather, save this for functions that do have a lot of potential options
that would otherwise require huge config structs or way too many arguments.

Typically, the functions that benefit from this the most are constructors or
initializes. In other words, setup functions that you want to be able to call
with anywhere from zero to many configuration options. These are functions used
to do all the setup for something like an API or database client.

Remember though, the zero value of a struct should be usable!

As these types of functions tend to require a lot of extra code to get working,
first consider a the following:

 - would a small 4-6 field configuration struct be simpler?
 - how many of the options can't be used at the same time; would it make more
   sense to break this function up into smaller more purpose-driven functions?
 - can it wait until after the function is called?

That last one is where you may usually find yourself; rather than a parameter in
a function that 99% of callers pass the zero value, have a method on the type
returned that handles the functionality needed by that 1% of the code.

**** Discourage The Use Of =nil= As A Valid Parameter Value
So this section opened with the suggestion that you shouldnâ€™t force the caller
of your API into providing you parameters when they donâ€™t really care what those
parameters mean. This is what we mean when we say you should design APIs for
their default use case.

Note: Dave Cheney picks on the =net/http= package a lot. In his words:

#+BEGIN_QUOTE
I donâ€™t mean to imply it, or the engineers who contributed to it, are bad. On
the contrary, =net/http= has been tremendously successful and with that success
has come a process of extension via accretion which makes it a great candidate
for case studies.
#+END_QUOTE

Anyways, code!

#+BEGIN_SRC go
package http

// ListenAndServe listens on the TCP network address addr and then calls
// Serve with handler to handle requests on incoming connections.
// Accepted connections are configured to enable TCP keep-alives.
//
// The handler is typically nil, in which case the DefaultServeMux is used.
//
// ListenAndServe always returns a non-nil error.
func ListenAndServe(addr string, handler Handler) error {
#+END_SRC

=ListenAndServe= takes two parameters, a TCP address to listen for incoming
connections, and =http.Handler= to handle the incoming HTTP request. =Serve= allows
the second parameter to be =nil=, and notes that usually the caller /will/ pass =nil=
indicating that they want to use =http.DefaultServeMux= as the implicit parameter.

Now the caller of Serve has this:

#+BEGIN_SRC go
http.ListenAndServe("0.0.0.0:8080", nil)
http.ListenAndServe("0.0.0.0:8080", http.DefaultServeMux)
#+END_SRC

Both do exactly the same thing.

This =nil= behaviour is viral. The =http= package also has a =http.Serve= helper,
which you can reasonably imagine that =ListenAndServe= builds upon like this

#+BEGIN_SRC go
func ListenAndServe(addr string, handler Handler) error {
	l, err := net.Listen("tcp", addr)
	if err != nil {
		return err
	}
	defer l.Close()
	return Serve(l, handler)
}
#+END_SRC

Because =ListenAndServe= permits the caller to pass =nil= for the second parameter,
=http.Serve= also supports this behaviour. In fact, =http.Serve= is the one that
implements the "if =handler= is =nil=, use =DefaultServeMux=" logic. Accepting =nil=
for one parameter may lead the caller into thinking they can pass =nil= for both
parameters. However calling Serve like this,

#+BEGIN_SRC go
http.Serve(nil, nil)
#+END_SRC

results in an ugly panic.

The author of =http.ListenAndServe= was trying to make the API userâ€™s life easier
in the common case, but possibly made the package harder to use safely.

There is no difference in line count between using =DefaultServeMux= explicitly,
or implicitly via =nil=.

#+BEGIN_SRC go
	const root = http.Dir("/htdocs")
	http.Handle("/", http.FileServer(root))
	http.ListenAndServe("0.0.0.0:8080", nil)
#+END_SRC

verses

#+BEGIN_SRC go
	const root = http.Dir("/htdocs")
	http.Handle("/", http.FileServer(root))
	http.ListenAndServe("0.0.0.0:8080", http.DefaultServeMux)
#+END_SRC

and a was this confusion really worth saving one line?

#+BEGIN_SRC go
	const root = http.Dir("/htdocs")
	mux := http.NewServeMux()
	mux.Handle("/", http.FileServer(root))
	http.ListenAndServe("0.0.0.0:8080", mux)
#+END_SRC

Give serious consideration to how much time helper functions will save the
programmer. Clear is better than concise.

Related to this guideline: avoid public APIs with test-only parameters. Avoid
exposing APIs with values which only differ in test scope. Instead, use public
wrappers to hide those parameters, use test scoped helpers to set the property
in test scope.

**** Prefer Variable Arguments to =[]T= Parameters
Itâ€™s very common to write a function or method that takes a slice of values.

#+BEGIN_SRC go
func ShutdownVMs(ids []string) error
#+END_SRC

This is just an example we just made up, but its common to a lot of code we've
all worked on. The problem with signatures like these is they presume that they
will be called with more than one entry. However, what often happens is that
many times these type of functions are called with only one argument, which has
to be "boxed" inside a slice just to meet the requirements of the functions
signature.

Additionally, because the ids parameter is a slice, you can pass an empty slice
or nil to the function and the compiler will be happy. This adds extra testing
load because you should cover these cases in your testing.

To give an example of this class of API, Dave Cheney was refactoring a piece of
logic that required him to set some extra fields if at least one of a set of
parameters was non zero. The logic looked like this:

#+BEGIN_SRC go
if svc.MaxConnections > 0 || svc.MaxPendingRequests > 0 || svc.MaxRequests > 0 || svc.MaxRetries > 0 {
	// apply the non zero parameters
}
#+END_SRC

As the if statement was getting very long, he wanted to pull the logic of the
check out into its own function. This is what he came up with:

#+BEGIN_SRC go
// anyPostive indicates if any value is greater than zero.
func anyPositive(values ...int) bool {
	for _, v := range values {
		if v > 0 {
			return true
		}
	}
	return false
}
#+END_SRC

This enabled him to make the condition where the inner block will be executed
clear to the reader:

#+BEGIN_SRC go
if anyPositive(svc.MaxConnections, svc.MaxPendingRequests, svc.MaxRequests, svc.MaxRetries) {
        // apply the non zero parameters
}
#+END_SRC

However there is a problem with =anyPositive=, someone could accidentally invoke
it like this

#+BEGIN_SRC go
if anyPositive() { ... }
#+END_SRC

In this case =anyPositive= would return false because it would execute zero
iterations and immediately return false. This isnâ€™t the worst thing in the
worldâ€‰â€”â€‰that would be if =anyPositive= returned true when passed no arguments.

Nevertheless it would be be better if we could change the signature of
=anyPositive= to enforce that the caller should pass at least one argument. We can
do that by combining normal and vararg parameters like this:

#+BEGIN_SRC go
// anyPostive indicates if any value is greater than zero.
func anyPositive(first int, rest ...int) bool {
	if first > 0 {
		return true
	}
	for _, v := range rest {
		if v > 0 {
			return true
		}
	}
	return false
}
#+END_SRC

Now =anyPositive= cannot be called with less than one argument.

**** Let Functions Define The Behaviour They Require
Letâ€™s say you've been given a task to write a method that persists a Document
structure to disk.

#+BEGIN_SRC go
  type Document struct {
    // mo' state
  }

  // Save writes the contents of the Document to the file f.
  func (d *Document) Save(f *os.File) error
#+END_SRC

You could specify this method, =Save=, which takes an =*os.File= as the destination to
write the =Document=. But this has a few problems.

The signature of =Save= precludes the option to write the data to a network
location. Assuming that in the new world of lambda functions and microservices,
network storage is likely to become requirement, the signature of this function
would have to change, impacting all its callers.

=Save= is also unpleasant to test, because it operates directly with files on
disk. To verify its operation the test would have to read the contents of the
file after being written. You would also have to ensure that =f= was written to a
temporary location and always removed afterwards.

Moreover =*os.File= defines a lot of methods which are not relevant to =Save=, like
reading directories and checking to see if a path is a symlink. It would be
useful if the signature of =Save= could describe only the parts of =*os.File= that
were relevant.

#+BEGIN_SRC go
// Save writes the contents of d to the supplied ReadWriterCloser.
func (d *Document) Save(rwc io.ReadWriteCloser) error
#+END_SRC

Using =io.ReadWriteCloser= we can apply the interface segregation principle to
redefine =Save= to take an interface that describes more general file shaped
things. With this change, any type that implements the =io.ReadWriteCloser=
interface can be substituted for the previous =*os.File=. This makes =Save= both
broader in its application, and clarifies to the caller of =Save= which methods of
the =*os.File= type are relevant to its operation. As the author of =Save= I no
longer have the option to call those unrelated methods on =*os.File= as it is
hidden behind the =io.ReadWriteCloser= interface. But we can take the interface
segregation principle a bit further.

Firstly, it is unlikely that if =Save= follows the single responsibility
principle, it will read the file it just wrote to verify its contentsâ€”â€‹that
should be responsibility of another piece of code.

#+BEGIN_SRC go
// Save writes the contents of d to the supplied WriteCloser.
func (d *Document) Save(wc io.WriteCloser) error
#+END_SRC

We can narrow the specification for the interface we pass to =Save= to just
writing and closing.

Secondly, by providing =Save= with a mechanism to close its stream, which we
inherited in this desire to make it still look like a file, this raises the
question of under what circumstances will =wc= be closed. Possibly =Save= will call
=Close= unconditionally, or perhaps =Close= will be called in the case of
success. Neither of these is a good option. Unconditionally closing =wc= after the
call to =Save= precludes the caller from writing additional data after the
document is written. Conditionally closing the =WriteCloser= â€‰â€”â€‰ it doesnâ€™t matter
if its on success, or failureâ€”â€‹means the caller must grow intricate knowledge of
the operation of =Save=.

#+BEGIN_SRC go
// Save writes the contents of d to the supplied Writer.
func (d *Document) Save(w io.Writer) error
#+END_SRC

A better solution would be to redefine =Save= to take only an io.Writer, stripping
it completely of the responsibility to do anything but write data to a stream.

By applying the interface segregation principle to our =Save= function, the
results has simultaneously been a function which is the most specific in terms
of its requirementsâ€”â€‹it only needs a thing that is writableâ€”â€‹and the most general
in its function, we can now use =Save= to save our data to anything which
implements =io.Writer=.

As a side effect it is clear that the name of the method is no longer accurate. A better name may be

#+BEGIN_SRC go
func (d *Document) WriteTo(w io.Writer) error
#+END_SRC

**** Export As Little As Possible
#+BEGIN_QUOTE
If you have a function which takes five parameters, you probably missed some. 

â€” Alan Perlis
#+END_QUOTE

In this document, we've presented many of the existing configuration patterns,
those considered idiomatic and commonly in use today, and at every stage asked
questions like:

 - Can this be made simpler?
 - Is that parameter necessary?
 - Does the signature of this function make it easy for it to be used safely?
 - Does the API contain traps or confusing misdirection that will frustrate?

Declarations provide the groundwork for a straightforward design, but it is the
active elements of a Go program; the functions, the methods and itâ€™s interfaces
which bear the weight of the design of a Go program.

If a function is public and does not have anything to do with the package or
uses none of the packages symbols, remove it. If it's used within the package,
un-export the function -- or better, move it to a package where it makes sense.

**** Don't Force Allocations On The Callers Of Your API
This section deals with performance. Most of the time when worrying about the
performance of a piece of code the overwhelming advice should be (with apologies
to Brendan Gregg) /donâ€™t worry about it, yet/. However there is one area where I
counsel developers to think about the performance implications of a design, and
that is API design.

Because of the high cost of retrofitting a change to an APIâ€™s signature to
address performance concerns, itâ€™s worthwhile considering the performance
implications of your APIâ€™s design on its caller.

**** A Tale Of Two API designs
Consider these two Read methods:

#+BEGIN_SRC go
func (r *Reader) Read(buf []byte) (int, error)
func (r *Reader) Read() ([]byte, error)
#+END_SRC

The first method takes a =[]byte= buffer and returns the number of bytes read into
that buffer and possibly an error that occurred while reading. The second takes
no arguments and returns some data as a =[]byte= or an error.

This first method should be familiar to any Go programmer, itâ€™s
=io.Reader.Read=. As ubiquitous as =io.Reader= is, itâ€™s not the most convenient API
to use. Consider for a moment that =io.Reader= is the only Go interface in
widespread use that returns /both/ a result /and/ an error.

Meditate on this for a moment.

The standard Go idiom, checking the error and if and only if it is =nil= is it safe
to consult the other return values, does not apply to =Read=. In fact the caller
must do the opposite. First they must record the number of bytes read into the
buffer, reslice the buffer, process that data, and only then, consult the
error. This is an unusual API for such a common operation and one that
frequently catches out newcomers.

Is this a trap for new developers?

Why is it so? Why is one of the central APIs in Go's standard library written
like this? A superficial answer might be =io.Reader='s signature is a reflection
of the underlying [[http://man7.org/linux/man-pages/man2/read.2.html][read(2)]] syscall, which is indeed true, but misses the point of
what we're trying to understand here.

If we compare the API of =io.Reader= to our alternative, =func Read() ([]byte,=
=error)=, this API seems easier to use. Each call to =Read()= will return the data
that was read, no need to reslice buffers, no need to remember the special case
to do this before checking the error. Yet this is not the signature of
=io.Reader.Read=. Why would one of Goâ€™s most pervasive interfaces choose such an
awkward API? The answer, we believe, lies in the performance implications of the
APIs signature on the caller.

Consider again our alternative =Read= function, =func Read() ([]byte, error)=. On
each call =Read= will read some data into a buffer and return the buffer to the
caller. Where does this buffer come from? Who allocates it? The answer is the
buffer is allocated inside =Read=. Therefore each call to =Read= is guaranteed to
allocate a buffer which would escape to the heap. The more the program reads,
the faster it reads data, the more streams of data it reads concurrently, the
more pressure it places on the garbage collector.

The standard librariesâ€™ =io.Reader.Read= forces the caller to supply a buffer
because if the caller is concerned with the number of allocations their program
is making this is precisely the kind of thing they want to control. Passing a
buffer into =Read= puts the control of the allocations into the callerâ€™s hands. If
they arenâ€™t concerned about allocations they can use higher level helpers like
[[https://golang.org/pkg/io/ioutil/#ReadAll][ioutil.ReadAll]] to read the contents into a =[]byte=, or [[https://golang.org/pkg/bufio/#Scanner][bufio.Scanner]] to stream
the contents instead.

The opposite, starting with a method like our alternative =func Read() ([]byte,=
=error)= API, prevents callers from pooling or reusing allocationsâ€“no amount of
helper methods can fix this. As an API author, if the API cannot be changed
youâ€™ll be forced to add a second form to your API taking a supplied buffer and
reimplementing your original API in terms of the newer form. Consider, for
example, [[https://golang.org/src/io/io.go?s=13136:13214#L378][io.CopyBuffer]]. Other examples of retrofitting APIs for performance
reasons are the fmt package and the =net/http= package which drove the
introduction of the =sync.Pool= type precisely because the Go 1 guarantee
prevented the APIs of those packages from changing.

If you want to commit to an API for the long run, consider how its design will
impact the size and frequency of allocations the caller will have to make to use
it.

*** Context
:PROPERTIES:
:ID:       6f31c55d-4d30-49f2-b311-52888942088e
:END:
One of the packages everybody learns about really early on in Go is the =context=
package and it's main star: =context.Context=. However, it's also kind of an odd
duck when you take a closer look at it. It's also one of the first
implementation details that you should consider as you design your API.

As of right now the =context= package does three things:

 - Cancellation via =context.WithCancel=
 - Timeout via =context.WithDeadline= or =context.WithTimeout=
 - A bag of values via =context.WithValue=

All three of these things are useful on their own, but why do we have three
different types of things in a single package?

We don't know the full story behind how =context= ended up this way, but the reason
we still have this strange package is the Go 1 API compatibility guarantee. If
you're not familiar, it's basically this sentence from the [[https://go.dev/doc/go1compat][Go 1 compatibility
guarantee]]:

#+BEGIN_QUOTE
It is intended that programs written to the Go 1 specification will continue to
compile and run correctly, unchanged, over the lifetime of that specification.
#+END_QUOTE

Basically, outside of some very specific circumstances detailed on that
compatibility page, we're stuck with the =context= package as it is today. And
that's not the worst thing in the world, either! What it does mean though, is
that for some packages from the standard library we need to have not only a
better understanding of how they work, but also a clear understanding on the
best practices around using them.

A good example of this is the =sync.WaitGroup= struct. Because Go passes by value
( via copy ), you can't pass a non-pointer =sync.WaitGroup= into a function; it
has to be a pointer otherwise it won't work -- and you'll be left with a program
that hangs forever because you copied a mutex and can't unlock.

So why is the context package one of these? Well, it has some gotchas that have
to be made clear before you really understand how to use it. Go has /fewer/
[[https://news.ycombinator.com/item?id=17393292][footguns]] than say, C++ -- but it still has a few laying about.

Let's dive into what =context.Context= can be used for then, and see how to best
make use of this strange little duck.

The best place to start is probably by taking a step back and taking a look at
the interface defined for us by the =context= package:

#+BEGIN_SRC go
  type Context interface {
    Deadline() (deadline time.Time, ok bool)
    Done() <-chan struct{}
    Err() error
    Value(key any) any
  }
#+END_SRC

So we've got a nice handy little interface here. What can we do with it?

Well, =Deadline()= will let us know if there is a deadline at all, =ok= will be
=false= if there's no deadline -- or when the deadline /is/.

=Done= returns a channel that's closed when the work being done on behalf of this
context should be canceled/finished.

=Err()= returns an error if the context has been canceled or the deadline has been
exceeded.

And =Value(any)= returns =any= -- which can be nil if no matching key was found.

Handy, right?

So what should we be watching out for?

**** Grab Bag Of Values
The very first thing that you should drill into your brain is this:
=context.Context= should *only ever hold request-local values*. Don't put in stuff
like loggers, database clients, API clients, or anything else that needs to be
shared across requests.

I'd even take it a bit further than others might, and say that you should only
store the following in a =context.Context= using =context.WithValue=:

 - =int= values
 - =float= values
 - =string= values
 - =map[string]string= values
 - =map[string]any= values

This list is less about type safety, and more about trying to prevent a
=context.Context= from getting too bloated by saying "put whatever you want in
it!". You can put other things into a =context.Context=, but if you try and stick
to only the types above you'll probably encounter fewer problems overall.

***** Contexts And Keys
So what about the keys? You can use any type you want, as the key is type
=any=. But what types are better -- or rather, what types should you prefer?

If you look around, some of the most common types you'll see are =string= and =int=
keys. Or rather, custom types based on =string= or =int=:

#+BEGIN_SRC go
  const keyForMetadata string = "boop"

  // later, in side a function within the package:
  ctx := context.WithValue(ctx, keyForMeatadata, metadata)
#+END_SRC

Let's first take a look at what this example is doing /right/. Right off the bat,
using a constant is a good idea, because then you don't have to worry about some
piece of code changing the key in-between when you set a value and when you
later wish to fetch it. Additionally, by using an unexported value, it means
that users can't use the key to get the value when we don't want.

Right?

#+BEGIN_SRC go
  // ex/ex.go
  package ex

  import "context"

  const key string = "what"

  func PutIntoCtx(ctx context.Context) context.Context {
    return context.WithValue(ctx, key, "some value")
  }

  // main.go
  package main

  import (
    "context"
    "fmt"

    "github.com/seanhagen/playground/ex"
  )

  func main() {
    ctx := context.Background()

    ctx = ex.PutIntoCtx(ctx)

    out := ctx.Value("what")

    fmt.Printf("got: %v\n", out)
  }
#+END_SRC

This prints out =got: some value= -- probably not what the package author
intended, right? If the data stored in that key is not meant to change, allowing
users to get their hands on it is not great.

So how do we fix this?

Well, the simplest way is to make this change to =ex/ex.go=:

#+BEGIN_SRC go
type ctxkey string 

const key ctxkey = "what"
#+END_SRC

Because checking equality on =any= requires checking the /type/ as well as the
value we don't have to worry about users getting to our data.

Is there anything we could do to make this better?

Yup!

#+BEGIN_SRC go
type ctxkey struct{}

var key = ctxkey{}
#+END_SRC

This is useful for at least two reasons.

One is that if you forget to use =key= and instead put =ctxkey{}= everything still
works; ~ctxkey{} == ctxkey{}~ is true. That's pretty great; it means we could
probably even just get rid of the ~var key = ctxkey{}~.

The other is that standardizing on =struct{}= as the type used for context keys
means one less potential allocation to worry about! This is one of those things
that isn't a big deal until it is; sticking with =struct{}= may or may not save
you some pain down the road.

However, as "use =struct{}= for context keys" is pretty easy to remember, we think
it's a good practice for us to put in place.

***** When To Put Something In A Context
So now that we've covered how to put stuff in a context, and what type to use
for the keys, let's talk about /when/ and /why/ to put stuff *into* a =context.Context=.

As the most common use of contexts is withing handlers for HTTP ( or GRPC )
requests, that's what we'll be talking about for the most part. There are some
other use-cases, but this document is already huge and you probably won't
encounter those cases very often.

Let's think about some things that you might put into a =context.Context= that you
want to be able to pull out at any point during the request. Stuff like:

  - request ID
  - trace or span ID
  - user ID, and maybe one or two other user details
  - /maybe/, *maybe*, MAYBE..... maybe some request parameters?

Those seem pretty reasonable -- but why the hesitation around request
parameters? Well, it has to do with how contexts work.

If you were asked to guess how the unexported concrete type or types that
fulfill the =context.Context= interface work, what would you say?

A good first guess is there's an unexported struct, with unexported fields, that
does all the work of managing timeouts or deadlines. There's something to manage
the channel for the =Done()= method. Some code for setting an =error= value on an
internal field when the context is canceled or times out that gets returned by
=Err()=. Lastly, some kind of map or other data store for the values added by
=WithValue=.

If you guessed that, you'd be as wrong as one of the authors of this was! 

#+BEGIN_NOTE
It was Hagen.
#+END_NOTE

Turns out, each =WithDeadline=, =WithTimeout=, =WithCancel=, and =WithValue= call pushes
the new context onto the head of a linked list, and returns the head.

Now, you should never ever *ever* store this many values shoved into a context,
but here's an example to show why keeping the number of values you put into a
context low is a good idea:

#+BEGIN_SRC go
  package main

  import (
    "context"
    "fmt"
    "time"

    "github.com/davecgh/go-spew/spew"
  )

  func main() {
    ctx := context.Background()

    ctx = context.WithValue(ctx, "what", "boop")

    for i := 1; i < 1_000_000; i++ {
      ctx = context.WithValue(ctx, fmt.Sprintf("key %v", i), i*i)
    }

    now := time.Now()
    v := ctx.Value("what")
    diff := time.Now().Sub(now)
    fmt.Printf("took: %v\ngot: %v\n", diff, v)
  }
#+END_SRC

This is what gets printed out:

#+BEGIN_SRC
took: 86.201678ms
got: boop
#+END_SRC

Ouch.

We should never end up in a position where we need to put that much stuff into a
context, but it's good to keep the fact that =context.Context= is really a linked
list in your head. Add to the fact that the context you get from a =*http.Request=
( or passed into your GRPC handler ) may already have a bunch of nodes in the
list, and you should be starting to see why we advise against putting too much
into a context with =context.WithValue=.

This is also why we advocate using a =map[string]string= if you want
to put multiple values at once into a context.

All that was basically a long-winded way to say: try to store as little as
possible in the request =context.Context=.

What's a good rule of thumb?

For now, you should only store values in a context inside of middleware. In
other words, never store values inside a context inside your
handler. Additionally, don't ever call =Value= yourself in your handler -- there
should be a helper function that gets the value out of the context and does the
nil & type check for you.

***** How To Put Something In A Context
Okay, so we've established the following:

 - use =struct{}= for context keys
 - store basic types, =map[string]string=, or =map[string]any=
 - store as little as you can get away with

Now let's talk about /how/ to store something in a context.

This is not how:

#+BEGIN_SRC go
ctx = context.WithValue(r.Context(), requests.CtxKey, requests.GenerateID(r))
#+END_SRC

How can we tell -- from one line of code -- that this isn't the right way?

Because we have to use two exported values from the =requests= package to set the
value. We've already spoken about exporting as little as possible and why that's
important. Another thing to consider is that by exporting the key and a method
to generate a request ID, we're leaving the actual /implementation/ of /putting/
/the ID into the context/ up to the user.

So let's think about /how/ we can put stuff into a context while still following
all the guidelines we've established so far.

Right off the bat we know that we don't want to export the context key, constant
or not. In most cases I'd argue users don't need to know the specifics of
getting a value out of a context -- they just want the value. And that's just in
the cases where they actually want the value, and not because they need the
value to do something else our package should be handling.

Rather than pontificate, let's look at an example: request ID!

Let's say there was a requirement that all our logs contain a 'request-id' field
( we're using structured logging in this example ).

If you're using a structured logging library like [[https://pkg.go.dev/go.uber.org/zap][zap]] your first thought might
be to use something like =With(...zap.Field)=:

#+BEGIN_SRC go
requestLogger := zap.With(zap.String("request-id", requests.GenerateID(r)))
#+END_SRC

If your next thought is to do this:

#+BEGIN_SRC go
ctx = context.WithValue(ctx, requests.LoggerCtxKey, requestLogger)
#+END_SRC

Then you need to re-read the entire [[#6f31c55d-4d30-49f2-b311-52888942088e][Context]] section.

What else could we do? Well we could pass the logger down into any function that
might need to write something to the logs. That's fine if you are A) creating
the logger in your handler and not middleware, and B) your handler doesn't call
many functions.

If you can get away with every handler not ever needing to pass the logger down
then huzzah! However, as I'd argue that generating the request ID should in
middleware and not your handler, that's no good. So that's both points A & B
shot down, so passing the logger down into each function is not a great
solution.

What if inverted things a bit? Let's look at two alternate solutions.

However, both start in the same place:

#+BEGIN_SRC go
  package request

  type requestIdKey struct{}

  func IdInCtx(ctx context.Context, r *http.Request) context.Context {
    return context.WithValue(ctx, requestIdKey{}, generateID(r))
  }
#+END_SRC

From our middleware or handler this is called as =request.IdInCtx(ctx, r)=, so
that's nice. Also, our context key is a =struct{}= and un-exported, also
good. Lastly, all the implementation details stay inside the =request= package --
the key, as well as function for generating the request ID are all un-exported.

So how do we /use/ the request ID?

Well, for our logging example there are two potential ways. Here's the first:

#+BEGIN_SRC go
  package request

  type RequestLogger interface {
    Info(string, ...any)
    With(args ...any) RequestLogger
  }

  func Logger(ctx context.Context, log RequestLogger) (RequestLogger, error) {
    v := ctx.Value(requestIdKey)
    if v == nil {
      return nil, fmt.Errorf("no request ID in context")
    }

    id, ok := v.(requestID)
    if !ok {
      return nil, fmt.Errorf("invalid type stored in context")
    }

    nl := log.With("request-id", id)
  }

  // in some function somewhere
  l := request.Logger(ctx, zap.L())
  l.Info("did thing to foobar")
#+END_SRC

You've probably noticed already that this doesn't work, =zap.L().Info= has a
signature of =(string, ...zap.Field)=, which we don't have in our interface. We
don't want to put =zap.Field= in the interface, as that's way too specific.

But we want some kind of interface, right? We don't want our =request= package to
know or care /what/ logging library we use, it just wants to add a field.

What if we change it up to this:

#+BEGIN_SRC go
  package request

  type AddFieldToLoggerFn func(key, value string)

  func AddIDToLogger(ctx context.Context, fn AddFieldToLoggerFn) error {
    v := ctx.Value(requestIdKey)
    if v == nil {
      return fmt.Errorf("no request ID in context")
    }

    id, ok := v.(requestID)
    if !ok {
      return fmt.Errorf("invalid type stored in context")
    }

    fn("request-id", id)

    return nil
  }
#+END_SRC

Better, but still not great. How do we ensure that the user uses =key= and =value=
in the function properly? Well, we can't. Still, better than the interface
version, right?

However, before we go further down this road, let's take a step back -- maybe we
need to think to our foundations; maybe there's something in the SOLID
principles that will guide us.

Turns out, there is! Fancy that.

In this case, it's the Single Responsibility Principle.

Think about what it is we're trying to do here: we want to have the =request-id=
included as a field in every log message generated inside a handler. So far, the
way we've been going about this is to add more to our =request= package --
specifically, trying to get it to be able to add a field to a logger without
knowing too much about the logger.

We haven't looked at the rest of the requests package, but adding "know how to
add a field to a structured logger" doesn't really /feel/ like it belongs in a
=request= package. It actually feels like "add a field to a structured logger"
belongs inside the handler; it is probably adding other fields like user ids, or
even trace & span ids.

So with that in mind, let's try something else instead. 

#+BEGIN_SRC go
  package foobar

  const (
    invalidRequestID RequestID = "invalid-ctx-no-request-id"
    requestIDKey     string    = "request-id"
  )

  // AddRequestIdTo is passed into RequestID.WithRequestID so that
  // the key and ID can be used to annotate whatever is required; adding
  // a field to a structured log, or an error, or whatever you want.
  type AddRequestIdTo func(key string, id RequestID)

  // RequestID is the custom type for our request ID so we can
  // hang some handy methods off it.
  type RequestID string

  // WithRequestID uses the function to pass in the proper key for
  // request IDs, along with the current request ID.
  func (rid RequestID) WithRequestID(fn AddRequestIdTo) {
    fn(requestIDKey, rid)
  }

  // InCtx puts the request ID into the context, creating a new
  // context if passed a nil context.
  func (rid RequestID) InCtx(ctx context.Context) context.Context {
    if ctx == nil {
      ctx = context.Background()
    }
    return context.WithValue(ctx, reqCtx, rid)
  }

  // our struct context key type
  type contextKeyType struct{}

  // our context key for storing/fetching the request ID
  var reqCtx = contextKeyType{}

  // RequestIdFromCtx returns either the request ID that was stored
  // in the context previously, or an 'invalid' request ID
  func RequestIdFromCtx(ctx context.Context) RequestID {
    v := ctx.Value(reqCtx)

    if id, ok := v.(RequestID); ok {
      return id
    }

    return invalidRequestID
  }
#+END_SRC

Hey hey! This is looking pretty handy. The only thing left to figure out is if
we want to define our own middleware so we don't have to expose =generateID=, or
just expose =generateID= so we don't have to build some middleware.

The quicker option is to export =generateID=, the safer option is to build some
middleware. Or at least, so long as generating the ID is a separate step. Can we
update =generateID= so that we can make things simpler?

#+BEGIN_SRC go
  func GenerateID(req *http.Request) (context.Context, RequestID) {
    id := buildIDFromHttpRequest(req)
    ctx := id.InCtx(req.Context())
    return ctx, id
  }
#+END_SRC

ðŸŽ‰ Huzzah! ðŸŽ‰

We've now got a method we can use in middleware that properly sets up both the
context and the request ID, and returns both.

We've got a function that lets you get the request ID out of the context.

We've got a method on the request ID type that allows anybody to use the request
ID to annotate a logger.

Doing it this way has another additional benefit, though: we now have a defined
way to annotate /anything/ with a request ID.

Want to annotate an outgoing request with the ID?

#+BEGIN_SRC go
  r := http.NewRequest(http.MethodPost, "http://example.com/an/api/route", http.NoBody)

  id.WithRequestID(func(key string, id RequestID) {
    r.Header.Add(key, string(id))
  })
#+END_SRC

Now we've got a function that can pull the request ID out of a context for when:

 - we're reporting an error to an external service
 - we're sending an event to a service like Mixpanel
 - we're annotating a trace with request info
 - we're adding some values to a header before returning from middleware

Oh, and we can use it when writing a log, of course.

So by focusing on the behaviour, we found our way to a solution that can be used
for lots of stuff, not just getting a request logger.

**** To Cancel, Or Not To Cancel
Now let's talk about the other use of contexts: cancellation.

A good place to start is this: why do we even care about being able to cancel
something before it's finished?

For folks coming from languages like Ruby, the idea of something like being able
to cancel a function from running might sound a bit odd. However, even if you're
brand-new to Go, you've probably heard about [[https://golangbot.com/goroutines/][goroutines]] and how goroutines are
key to Go's magical "easy concurrency". All this hullabaloo about cancellation
has to do with the fact that goroutines need some way to be told "hey, I need to
you stop doing what you're doing and exit promptly".

Folks coming from languages with threads ( or some equivalent ) probably wonder
why we can't just stop or kill goroutines directly, via a handle or some
built-in thread management functions. Unfortunately, unlike threads, goroutines
are a "launch and forget" kind of thing. The only way you have to tell a
goroutine to stop without also killing your entire program is through a context
( or a channel, but we're not going over those right now ).

We went over this in the concurrency section but it's worth stating again: DO
NOT launch a goroutine without having some way of telling the goroutine to stop.

So we're all on the same page, here's what launching a goroutine looks like:

#+BEGIN_SRC go
  func boop() {
    <-time.After(time.Second)
    fmt.Printf("boop!\n")
  }

  func main() {
    fmt.Printf("Launching goroutine!\n")
    go boop()
    time.Sleep(time.Millisecond * 500)
    
    fmt.Printf("Launching another goroutine!\n")
    go boop()
    time.Sleep(time.Millisecond * 500)

    fmt.Printf("Launching one last goroutine!\n")
    go boop()
    time.Sleep(time.Millisecond * 500)
  }
#+END_SRC

Real quick, what do you think this program prints out?

If you guessed this:

#+BEGIN_SRC
Launching goroutine!
Launching another goroutine!
boop!
Launching one last goroutine!
#+END_SRC

Then you're either real smart, or real lucky. Maybe go buy a lottery ticket to
test that.

However, if you didn't guess that, you're probably wondering where the two other
missing =boop!= lines are.

Well, this is the first thing we've got to deal with when using goroutines. When
we get to the end of =main.main= /all running goroutines stop/. So that's one way to
cancel a goroutine: call =os.Exit(1)=!

We're guessing you don't want to have to cause your program to exit every time
you want to stop a goroutine. For one thing, it means you could never have more
than one goroutine running at a time. As incoming requests for both HTTP and
GRPC services are handed off to goroutines, this is less than ideal.

So what other options do we have for stopping a goroutine?

Well, as we're still talking about contexts, you can probably guess what the
answer is.

#+BEGIN_SRC go
  package main

  import (
    "context"
    "fmt"
    "time"
  )

  func boop(ctx context.Context, id int) {
    tick := time.NewTicker(time.Second)

    for {
      select {
      case <-ctx.Done():
        fmt.Printf("Context cancelled, quitting goroutine %v!\n", id)

      case <-tick.C:
        fmt.Printf("Boop from goroutine %v\n", id)
      }
    }
  }

  func main() {
    ctx := context.Background()
    ctx = context.WithTimeout(ctx, time.Second * 3)

    for i:=1; i<=3; i++ {
      go boop(ctx, i)
    }

    time.Sleep(time.Second * 10)

    fmt.Printf("exiting!")
  }
#+END_SRC

That code prints out the following:

#+BEGIN_SRC
Boop from goroutine 2
Boop from goroutine 3
Boop from goroutine 1
Boop from goroutine 2
Boop from goroutine 3
Boop from goroutine 1
Boop from goroutine 2
Boop from goroutine 1
Context cancelled, quitting goroutine 2!
Boop from goroutine 3
Context cancelled, quitting goroutine 1!
Context cancelled, quitting goroutine 3!
exiting!
#+END_SRC

Two things to note. First, the code actually has a bug, see if you can find
it. Second, in between the second line and the last line was a ~8 second pause,
because of the =time.Sleep=. What if we waited on the context, instead? 

#+BEGIN_SRC go
	<-ctx.Done()
	//time.Sleep(time.Second * 10)
#+END_SRC

What do we get now?

#+BEGIN_SRC
Boop from goroutine 2
Boop from goroutine 3
Boop from goroutine 1
Boop from goroutine 2
Boop from goroutine 1
Boop from goroutine 3
Boop from goroutine 2
Context cancelled, quitting goroutine 2!
Boop from goroutine 1
Boop from goroutine 3
Context cancelled, quitting goroutine 3!
exiting!
#+END_SRC

Oops! One of our =goroutines= didn't get a chance to clean up! This is because as
soon as the scheduler goes back to =main.main=, the program prints 'exiting!' and,
well, exits. What if we need to make sure the =goroutine= cleans up after itself?

Maybe =defer= is what we want.

#+BEGIN_SRC go
func boop(ctx context.Context, id int) {
	defer func() {
		fmt.Printf("goroutine %v defer!\n")
	}()

	tick := time.NewTicker(time.Second)
#+END_SRC

And the output now is:

#+BEGIN_SRC
Boop from goroutine 2
Boop from goroutine 3
Boop from goroutine 1
Boop from goroutine 3
Boop from goroutine 2
Boop from goroutine 1
Boop from goroutine 2
Boop from goroutine 1
Boop from goroutine 3
Context cancelled, quitting goroutine 2!
Context cancelled, quitting goroutine 3!
Context cancelled, quitting goroutine 1!
goroutine 1 defer!
goroutine 2 defer!
exiting!
#+END_SRC

Well.... drat. The =defer= added enough time for all the =goroutines= to hit the
cancellation bit -- but =goroutine= 3 failed to execute it's =defer=! This problem
is only going to get worse as we add more and more =goroutines=. So what can we do?

Well, if you need to wait for a bunch of =goroutines= to finish, use
=sync.WaitGroup=.

#+BEGIN_SRC go
  func boop(ctx context.Context, wg *sync.WaitGroup, id int) {
    defer func() {
      fmt.Printf("goroutine %v defer!\n", id)
      wg.Done()
    }()

    tick := time.NewTicker(time.Second)

    for {
      select {
      case <-ctx.Done():
        fmt.Printf("Context cancelled, quitting goroutine %v!\n", id)
        return

      case <-tick.C:
        fmt.Printf("Boop from goroutine %v\n", id)
      }
    }
  }

  func main() {
    ctx := context.Background()
    ctx, cancel := context.WithTimeout(ctx, time.Second*3)
    defer cancel()

    wg := &sync.WaitGroup{}

    for i := 1; i <= 3; i++ {
      wg.Add(1)
      go boop(ctx, wg, i)
    }

    wg.Wait()

    fmt.Printf("exiting!")
  }
#+END_SRC

So why did we go through all this?

To show that =context.Context= is for /cancellation/. It does not help when you need
to wait for something to finish.

**** Final Thoughts

Let's take a step back for a moment and consider the purpose of a
=context.Context=. It's a way to store values that /may/ be needed later on during a
request; whether that request is a function call or an HTTP request doesn't
really matter. It's also a way to pass into a function a way of saying "hey,
just stop, I don't need you to do any more work".

Both of these behaviours are valuable. We don't want a database call to continue
when the request was canceled by the user. At the same time, we need a single
way to handle passing values down the call stack that /might/ be required.

One thing you're probably wondering is why we're saying "might" and "may" or
"maybe" when talking about the values shoved into a =context.Context= using
=context.WithValue=. Well, the reason is the untyped nature of what gets stored in
a context. While this isn't correct, you can think of the data being shoved into
a =map[any]any=. So not only are the keys untyped, but so are the
values that are saved. Additionally, =context.WithValue= is copy-on-write, meaning
no storing stuff like =sync.Mutex=.

So what kinds of things /should/ we put in a =context.Context=?

A good place to start is this:

#+BEGIN_NOTE
Only data that isn't needed to handle the request can be stored in a
=context.Context=.
#+END_NOTE

Not bad, but still needs some work. The word "data" can mean too many things
here. Let's narrow that down a bit.

#+BEGIN_NOTE
Only /concrete types/ that aren't needed to handle the request can be stored in a =context.Context=.
#+END_NOTE

Still to vague; =http.Request= is a concrete type but you should *never* put it into
a =context.Context=.

#+BEGIN_NOTE
Only /built-in types/ holding data that isn't needed to handle the request can be
stored in a =context.Context=
#+END_NOTE

Whoops, now our whole =RequestID= example is invalid. Let's open it up a tiny bit.

#+BEGIN_NOTE
Only /built-in types or user types that extend built-in types/ that are holding
data that isn't needed to handle the request can be stored in a =context.Context=
#+END_NOTE

Hrmmm. =struct{}= is a built in type. What we want are /basic/ types. However, we
don't want to say 'basic' here, that's still confusing. We're also trying to
define what we /don't/ want. We don't want types based on =struct= because those can
get way too big. What about slices or maps? Well, because those can be
=[]any= or =map[any][any]= we don't want those. What do structs, slices, and maps
all have in common? They're composite types!

#+BEGIN_NOTE
Only /built-in, non-composite types or user types that extend such types/ that are holding
data that isn't needed to handle the request can be stored in a =context.Context=
#+END_NOTE

Okay! Let's do a quick sniff test.

 - =http.Request=? composite type, not allowed
 - =*zap.SugaredLogger=? same, still a composite type
 - our custom =RequestID=? it's based on =string=, so that's fine

That sounds pretty reasonable, right? We could probably extend this definition
to cover more and more use cases. However, at that point your problem isn't that
developers don't understand this rule -- it's that they don't think it's a good
rule.

This is where we, unfortunately, have to communicate. Yes, sometimes we have to
remember we're part of a team, and that means discussing things until a
compromise is reached.

Plus, there might be some cases where we want to put a struct into a context --
despite just having spent many paragraphs saying why that's probably a bad idea.

So for now, here's a second rule for /where/ you can put stuff into a context:

#+BEGIN_NOTE
The only place data can be placed into a context is in any request-serving
middleware.
#+END_NOTE

That's a pretty good rule, right? The middleware is where most of the data we
want to put into the context is, after all. We don't want to have to remember to
put the request ID into the context in each handler -- so we do it in
middleware.

So what makes sense to put in the context, given this additional rule?

 - request ID
 - trace & span ID
 - some kind of user ID for routes that have to authenticate the user in the middleware
 - some kind of tracking ID, which may just be the user ID

There may be some other pieces of data that are worth pulling out of the request
and putting in the context, but probably not many. Maybe if there are any custom
header values for things like feature flags and the like. Otherwise, try to keep
the number of things being put into the context /as low as possible/.

Notice we're not giving a maximum for how many things to put into a
=context.Context=. The reason is one we've already gone over above: the same way
that some requests may need to put a =struct= into the context, some requests may
need to store twenty things in the =context.Context=.

HOWEVER.

Doing so should be a last resort.

Yes, there are times when you don't have any option but stuffing a bunch of
stuff into a =context.Context=. For example, [[https://github.com/grpc/grpc-go/blob/master/Documentation/grpc-metadata.md][metadata for GRPC calls]] is put into a
map... that's then put into a =context.Context=. This is how GRPC handles what are
basically HTTP headers. In such situations though, consider how much metadata is
actually required -- the other side of the GRPC call has to deal with all that
metadata, and if the GRPC service is written in Go all that metadata is being
shoved back into a =context.Context= on the other side. One upside is that it's
possible to /replace/ the metadata in a =context.Context= instead of just appending
more, but that's not something we should rely on.

